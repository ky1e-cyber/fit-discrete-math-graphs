#import "template.typ": *

#show: doc => template(doc)

= Лекция 1 часть 2
== Базовая терминология и специальные типы графов.

#definition()[Две вершины $u$ и $v$ в неориентированном графе $G$ называются _смежными_ в $G$, если $u$ и $v$ являются конечными точками ребра $e$ графа $G$. Такое ребро $e$ называется _инцидентным_ вершинам $u$ и $v$. Также говорят, что ребро $e$ соединяет вершины $u$ и $v$.]

#definition()[Множество всех соседей вершины $v$ в графе $G = (V, E)$, обозначаемое $N(v)$, называется _окружением_ $v$.
Если $A$ является подмножеством $V$, то мы обозначаем $N(A)$ множество всех вершин в $G$, которые смежны с более чем одной вершиной из $A$. Таким образом: $ N(A) = union.big_(v in A) N(v) $]

#definition()[_Степень вершины_ в неориентированном графе — это
количество инцидентных ей ребер. Степень вершины $v$ обозначается как $deg(v)$. Вершина степени ноль называется _изолированной_. Изолированная вершина не смежна ни с одной другой вершиной.
Вершина степени 1 называется _висячей_.]

#theorem(name: "Теорема о рукопожатии")[Пусть $G = (V, E)$ — неориентированный граф с $m$ ребрами. Тогда $ 2m = sum_(v in V) deg(v) $]

#collolary()[Неориентированный граф имеет четное число вершин нечетной степени.][Пусть $V_1$ — множество вершин четной степени, а $V_2$ — множество вершин нечетной степени в неориентированном графе $G = (V, E)$ с $m$ ребрами. Тогда $ 2m = sum_(v in V) deg(v) = sum_(v in V_1) deg(v) + sum_(v in V_2) deg(v) $
Поскольку $deg(v)$ четно для $v in V_1$ , первый член в правой части последнего равенства четный. Более того, сумма двух членов в правой части последнего равенства четная, поскольку эта сумма равна $2m$. Следовательно, второй член в сумме также четный. Поскольку все члены в этой сумме нечетные, таких членов должно быть четное количество. Таким образом, имеется четное количество вершин нечетной степени.]

== Терминология для ориентированных графов.

#definition()[Когда $(u, v)$ является ребром ориентированного графа $G$, говорят, что вершина $u$ является начальной вершиной ребра $(u, v)$, а вершина $v$ является конечной.]

#definition()[В ориентированном графе _полустепень
захода_ вершины $v$, обозначаемая как $deg^-(v)$, — это количество ребер, имеющих вершину $v$ в качестве конечной вершины. 

_Полустепень исхода_ вершины $v$, ​обозначаемая как $deg^+(v)$, — это количество ребер, имеющих вершину $v$ в качестве начальной вершины.]

#theorem()[Дан ориентированный граф $G = (V, E)$. Тогда $ sum_(v in V) deg^-(v) = sum_(v in V) deg^+(v) = abs(E) $]

#definition()[Неориентированный граф, который получается в результате игнорирования направлений ребер, называется _основанием_.]

== Специальные типы простых графов.

#definition()[_Полный граф_ на $n$ вершинах, обозначаемый $K_n$, — это простой граф, содержащий ровно одно ребро между каждой парой различных вершин. Простой граф, для которого существует по крайней мере одна пара различных вершин, не соединенных ребром, называется _неполным_.]

#definition()[_Цикл_ $C_n$, $n gt.eq 3$, состоит из $n$ вершин $v_1, v_2, dots , v_n$ и ребер ${v_1, v_2}, {v_2, v_3}, dots, {v_(n−1), v_n}$ и ${v_n, v_1}$.]

#definition()[_Kолесо_ $W_n$ получаем, когда к циклу $C_n$ добавляется дополнительная вершина, для $n gt.eq 3$, и эта новая вершина соединяется с каждой из $n$ вершин цикла $C_n$ новыми ребрами.]

#definition()[Простой граф $G$ называется _двудольным_, если множество его вершин $V$ можно разбить на два непересекающихся множества $V_1$ и $V_2$ так, что каждое ребро в графе  соединяет вершину в $V_1$ и вершину в $V_2$ так что ни одно ребро в $G$ не соединяет никакие две вершины в $V_1$ , и  никакие две вершины в $V_2$. Когда это условие выполняется, мы называем пару $(V_1, V_2)$ двудольным _разбиением множества вершин $V$_.]

#definition()[Полный двудольный граф $K_(m,n)$ — это граф, множество вершин которого разделено на 2 подмножества по $m$ и $n$ вершин соответственно, так что один конец каждого ребра находится в первом подмножестве, а второй конец — во втором подмножестве.]

#definition()[$n$-мерный гиперкуб, или $n$-куб, обозначаемый $Q_n$, — это граф, вершины  которого представляют $2n$ битовых строк длины $n$.]

// TODO: add images

#definition()[_Подграф_ графа $G = (V, E)$ — это граф $H = (W, F)$, где $W subset.eq V$ и $F subset.eq E$. Подграф $H$ графа $G$ является _собственным подграфом_ графа $G$, если $H eq.not G$. Для заданного набора вершин графа мы можем образовать подграф этого графа с этими вершинами и ребрами графа, которые их соединяют. Подграф, полученный путем удаления ребер, называется _остовным подграфом_ графа $G$.]

#definition()[Пусть $G = (V, E)$ — простой граф. Подграф, _индуцированный_ $W subset V$, — это граф $(W, F)$, где множество ребер $F$ содержит ребро из $E$: обе концевые вершины этого ребра находятся в $W$. 

Новый граф, содержащий все вершины и ребра этих графов, называется _объединением графов_.

_Пересечение_ двух простых графов $G_1 = (V_1 , E_1)$ и $G_2 = (V_2, E_2 )$ — это простой граф с множеством вершин $V_1 inter V_2$ и множеством ребер $E_1 inter E_2$.

_Дополнение_ простого графа $G$ граф $G'$ имеет те же вершины,
что и $G$. Если две вершины смежны в $G'$ они не смежны в $G$.]

= Лекция 2
== Представления графов и изоморфизм графов.

Один из способов представить простой граф $G$ (без кратных ребер) — перечислить все ребра этого графа.  Другой способ представить граф без кратных ребер — использовать _списки смежностей_, в которых перечисляются вершины, смежные с каждой вершиной графа.

#figure(
  table( columns: (auto, auto), align: horizon, table.header([Вершина], [Смежные вершины],), $a$, $b, c, e$, $b$, $a$, $c$, $a, d, e$, $d$, $c, e$, $e$, $a, c, d$), 
  caption: [Пример cписков смежности],
  supplement: none
)

#definition()[Дан простой граф $G = (V, E)$, где $V = n$ . Предположим, что вершины $G$ перечислены в произвольном порядке $v_1, v_2, dots, v_n$ .  _Матрица смежности_ $A$ графа $G$ относительно этого списка вершин, — это бинарная матрица $A = [a_(i,j)] $ размера $n crossmark n$ и $ a_(i,j) = cases("1, " {v_i, v_j} in V, "0, иначе") $]

Матрица смежности простого графа симметрична, то есть $а_(i,j) = а_(j, i)$.

Поскольку простой граф не имеет петель, каждый диагональный элемент матрицы смежности равен нулю.

Когда несколько ребер соединяет одну и ту же пару вершин $v_i$ и $v_j$ или имеется несколько петель в одной и той же вершине, матрица смежности больше не является бинарной матрицей, поскольку элемент $a_(i,j)$ этой матрицы равен количеству ребер между вершинами $v_i$ и $v_j$.

Матрица смежности ориентированного графа определяется аналогично, но не обязана быть симметричной.

Другой распространенный способ представления графов — использование матриц инцидентности. 

#definition()[Пусть $G = (V, E)$ — неориентированный граф. Предположим, что $v_1, v_2, dots, v_n$ — вершины, а $e_1, e_2, dots, e_m$ — ребра графа $G$. Тогда _матрица инцидентности_ относительно некоторого порядка вершин и ребер представляет собой матрицу размера $n crossmark m$. $M = [m_(i,j)]$, где $ m_(i,j) = cases("1, ребро" e_j "инцидентно" v_i, "0, иначе") $]

#figure(
$ #table(
    columns: (auto,)+(3pt,)+(auto,)*5+(3pt,),
    stroke: none,
    align: (right + horizon,) + (center + horizon,)*7,
    [],[], $e_1$, $e_2$, $e_3$, $e_4$, $e_5$, [],
    $v_1$, "", $0$, $0$, $1$, $0$, $1$, "",
    $v_2$, "", $0$, $0$, $1$, $0$, $1$, "",
    $v_3$, "", $1$, $0$, $0$, $1$, $1$, "",
    $v_4$, "", $0$, $1$, $0$, $0$, $0$, "", 
    $v_5$, "", $0$, $0$, $0$, $1$, $0$, "",
    $v_6$, "", $1$, $0$, $0$, $0$, $0$, "",
  ) $,
  caption: [ Пример матрицы инцидентности ], 
  supplement: none
)

== Изоморфизм графов.

#definition()[Простые графы $G_1 = (V_1, E_1)$ и $G_2 = (V_2, E_2)$ изоморфны, если существует биекция $phi: V_1 arrow V_2$, обладающая свойством, что если вершины $a$ и $b$ смежны в G1 $=>$ их образы $phi(a)$ и $phi(b)$ смежны в $G_2$ $forall a, b in V_1$. Такая биекция $phi$ называется изоморфизмом. Два простых графа, не являющихся изоморфными, называются неизоморфными. Другими словами, когда два простых графа изоморфны, существует биекция между вершинами двух графов, которая сохраняет отношения смежности.]

Изоморфизм простых графов — это отношение эквивалентности.
Есть $n!$ возможных биекций между множествами вершин двух простых графов с $n$ вершинами.

В частности, мы можем показать, что два графа не изоморфны, если мы можем найти свойство, которым обладает только один из двух графов, но которое сохраняется изоморфизмом.

Свойство, сохраняемое изоморфизмом графов, называется _инвариантом графа_.
Примеры инвариантов:  кол-во вершин, кол-во рёбер, количество вершин каждой степени.

Чтобы показать, что $phi$ является изоморфизмом, можно показать, что матрица смежности $G$ совпадает с матрицей смежности $H$.

Лучшие алгоритмы, известные для определения изоморфности двух графов, имеют экспоненциальную временную сложность в худшем случае (по количеству вершин графов).

== Связность.

#definition()[Пусть $n$ — целое неотрицательное число, а $G$ — неориентированный граф. _Путь_ длины​ $n$ из вершины $u$ в вершину $v$ в $G$ - это последовательность $n$ ребер $e_1, dots, e_n$ графа $G$, для которой существует последовательность вершин $х_0 = u$, $х_1, dots, х_(n−1)$, $х_n = v$ такая, что ребро $e_i$ имеет конечными точками вершины $x_(i−1)$ и $x_i$ для $i = 1 dots n$. Когда граф простой, мы обозначаем этот путь последовательностью его вершин $х_0, х_1, dots, х_n$ (поскольку перечисление этих вершин однозначно определяет путь).

Путь — это _цикл_, если он начинается и заканчивается в одной и той же вершине, то есть если $u = v$, и имеет длину больше нуля. Говорят, что путь или цикл проходит через вершины $x_1, х_2, dots, x_(n−1)$ или  проходит по ребрам $e_1, е_2, dots, e_n$. Путь или цикл являются _простыми_, если они не содержат одно и то же ребро более одного раза.]

Путь для ориентированного графа определяется аналогично.

#definition()[Неориентированный граф называется связным если между каждой парой различных вершин графа существует путь. Неориентированный граф, который не является связным, называется несвязным. Мы говорим, что мы делаем граф несвязным, когда удаляем вершины или ребра, или и то, и другое, чтобы построить несвязный подграф.]

#theorem()[Между каждой парой различных вершин связного неориентированного графа существует простой путь.][Пусть $u$ и $v$ — две различные вершины связного неориентированного графа $G = (V, E)$. Поскольку $G$ связен, между $u$ и $v$ существует $gt.eq$ 1 пути. Пусть $x_0, x_1, dots, x_n$, где $x_0 = u$ и $x_n = v$ — последовательность вершин пути наименьшей длины. Этот путь наименьшей длины является простым. Чтобы увидеть это, предположим, что этот путь не простой. Тогда $x_i = x_j$ для некоторых $0 lt.eq i lt j$. Это означает, что существует путь от $u$ до $v$ меньшей длины с последовательностью вершин $x_0, x_1, dots, x_(i−1), x_j, dots, x_n$ полученный удалением ребер, соответствующих последовательности вершин $x_i, dots, x_(j−1)$]

Существование простого цикла определенной длины является полезным инвариантом, который можно использовать, чтобы показать, что 2 графа не изоморфны. Кроме того, пути можно использовать для построения отображений, которые могут быть изоморфизмами. Как мы уже упоминали, полезным инвариантом изоморфизма для простых графов является существование простого цикл длины $k gt 2$.

#definition()[Компонента связности графа $G$ — это связный подграф графа $G$, который не является собственным подграфом другого связного подграфа $G$. То есть, связная компонента графа $G$ является максимальным связным подграфом $G$. Несвязный граф $G$ имеет $gt.eq 2$ компонент связности, которые не пересекаются и имеют $G$ в качестве своего объединения.]

== Двудольные графы. Признаки двудольности графа.

#theorem()[Простой граф является двудольным $<=>$ каждой вершине графа можно присвоить один из двух различных цветов так, что никаким двум смежным вершинам не будет присвоен один и тот же цвет.][$=>$ Предположим, что $G = (V, E)$ — двудольный простой граф. Тогда $V = V_1 union V_2$, где $V_1$ и $V_2$ являются непересекающимися множествами, и каждое ребро в $E$ соединяет вершину в $V_1$ и вершину в $V_2$. Если мы присвоим один цвет каждой вершине в $V_1$, а второй цвет - каждой вершине в $V_2$, тогда каждое ребро будет соединять вершины разного цвета.

$arrow.l.double$ Теперь предположим, что можно присвоить вершинам графа всего 2 цвета так, чтобы никаким двум смежным вершинам не был присвоен один и тот же цвет. Пусть $V_1$ — множество вершин одного цвета, а $V_2$ множество вершин другого цвета. Тогда $V_1$ и $V_2$ не пересекаются и $V = V_1 union V_2$. Более того, каждое ребро соединяет вершину в $V_1$ и вершину в $V_2$, поскольку никакие две смежные вершины не находятся одновременно в $V_1$ или одновременно в $V_2$. Следовательно, граф $G$ является двудольным.]

#theorem()[Простой граф $G$ является двудольным $<=>$ в нем нет циклов с нечетным количеством ребер.][$=>$ Если граф двудольный, скажем, с долями $A$ и $B$, то вершины каждого пути должны попеременно находиться в $A$ и $B$. Поэтому путь, начинающийся, скажем, в $A$, закончится в $B$ после нечетного числа шагов и в $A$ после четного числа шагов. Поскольку цикл заканчивается в той же вершине, где он начинается, длина пути должна быть четной.

$arrow.l.double$ Предположим, что все циклы имеют четную длину, и хотим показать, что граф является двудольным. Мы можем предположить, что граф связен, поскольку если это не так, то мы можем работать только с одной компонентой связности за раз. Пусть $v$ - вершина графа, и пусть $A$ — множество всех вершин, к которым ведет путь нечетной длины , начинающийся в $v$, и пусть $B$ — множество всех вершин, к которым ведет путь четной длины. Поскольку компонент связен, каждая вершина лежит либо в $A$ или $B$. Ни одна вершина не может принадлежать как $A$, так и $B$, поскольку в этом случае следование по пути нечетной длины от $v$ до этой вершины, а затем обратно по пути четной длины от этой вершины до $v$ приведет к образованию нечетного цикла, что противоречит гипотезе. Таким образом, множество вершин было разделено на два множества. Теперь нам просто нужно показать, что каждое ребро имеет конечные точки в разных долях графа. Если $(х, у)$ это ребро, где $x in A$, затем путь нечетной длины от $v$ до $x$, за которым следует $(х, у)$ создает путь четной длины от $v$ до $y$, поэтому $y in B$ (и аналогично, если $x in B$).]

= Лекция 3
== Матрицы смежности и структурные свойства графов.

Если граф $G$ неориентированный, то его матрица смежности $А$ является симметричной, то есть $A^T = A$. По определению, индексы ненулевых элементов $i$-й строки соответствуют соседям вершины $v_i$. Аналогично, ненулевые индексы $i$-го столбца матрицы $A$ соответствуют соседям вершины $v_i$.

В частности, собственные значения и собственные векторы матрицы смежности можно использовать для вывода таких свойств, как двудольность, степень связности и многих других. Поэтому такой подход к теории графов называется спектральной теорией графов.

Будем обозначать единичную матрицу как $I$, а матрицу, все элементы которой равны 1, будем обозначать как $J$.

Степень вершины $v_i$ равна сумме элементов в $i$-й строке (или $i$-ом столбце) матрицы $A$, то есть
$ deg(v_i) = sum_(j = 1)^n A(i,j) = sum_(j = 1)^n A(j,i) $

Если обозначить вектор-столбец, состоящий из всех 1, через $e = (1, 1, dots, 1)$, то $ A e = vec(deg(v_1), deg(v_2), dots, deg(v_n))  $

Мы будем называть $A e$ вектором степеней графа $G$. После возможной перестановки вершин, $A e$ равен степенной последовательности графа $G$.

== Подсчёт количества путей.

#theorem()[Для любого графа $G$ с множеством вершин $V = {v_1, v_2, dots, v_n}$, элемент $(i, j)$ матрицы $A^k$ представляет собой количество путей из вершины $v_i$ в вершину $v_j$ длины $k$.][
Доказательство проводится индукцией по $k$. Для $k = 1$, $A(i,j) = 1$ означает, что вершины $v_i$ и $v_j$ являются смежными, и значит, существует путь длины $k = 1$ из вершины $v_i$ в вершину $v_j$.

С другой стороны, если $A(i,j) = 0$, то вершины $v_i$ и $v_j$ не являются смежными, и тогда очевидно, что не существует пути длины $k = 1$ из вершины $v_i$ в вершину $v_j$. Теперь предположим, что утверждение верно для некоторого $k gt.eq 1$, и рассмотрим количество путей длины $k + 1$ из вершины $v_i$ в вершину $v_j$. Любой путь длины $k + 1$ из $v_i$ в $v_j$ содержит путь длины $k$ из $v_i$ в некоторого соседа вершины $v_j$. Если вершина $v_p in N(v_j)$, то по индукции количество путей длины $k$ из $v_i$ в $v_p$ равно $A^k(i,p)$. Следовательно, общее число путей длины $k + 1$ из $v_i$ в $v_j$ равно $ sum_(v_p in N(v_j)) A^k(i,p) = sum_(l=1)^n A^k(i,l) A(l,i) = A^(k+1)(i,j) $]

== Матрицы смежности и связность графа.

#definition()[_След_ (trace) матрицы $M$ представляет собой сумму ее диагональных элементов и будет обозначаться как $tr(M)$: $tr(M) = sum_(i=1)^n M(i,i)$]

Поскольку все диагональные элементы матрицы смежности $A$ равны нулю, то $tr(A) = 0$.

#collolary()[Пусть $G$ — граф с матрицей смежности $A$,
- $m$ - количество ребер в графе $G$,
- $t$ - количество треугольников в $G$,
- $q$ - количество циклов длины 4 в $G$.
Тогда верны следующие равенства:
+ $tr(A^2) = 2m$
+ $tr(A^3) = 6t$
+ $tr(A^4) = 8q - 2m + 2 sum_(i = 1)^n deg(v_i)^2$][
1. Элемент $A^2(i,i)$ представляет собой количество замкнутых путей из $v_i$ в $v_i$ длины $k = 2$. Замкнутый путь длины $k = 2$ имеет 1 ребро. Следовательно, $ tr(A^2) = sum_(i=1)^n A^2(i,i) = sum_(i=1)^n deg(v_i) = 2m $
2. Чтобы доказать второе утверждение, начнем с того, что замкнутый путь можно пройти двумя различными способами. Следовательно, для каждой вершины $v$ в треугольнике существует 2 пути длины $k = 3$, которые начинаются в $v$ и обходят треугольник. Поскольку каждый треугольник содержит 3 различные вершины, на каждый треугольник в графе приходится 6 путей длины $k = 3$. Так как $sum_(i=1)^n A^3(i,i)$ подсчитывает все пути в $G$ длины 3, то имеем $ tr(A^3) = sum_(i=1)^n A^3(i,i) = 6t $
3. #text[
Рассмотрим $tr(A^4) = sum_(i=1)^n A^4(i,i)$. Подсчитываем количество замкнутых путей длины $k = 4$ из $v_i$. Существует 3 типа таких путей:
#enum(numbering: "a.",
  enum.item(1)[замкнутые пути вида $(v_i, x, v_i, y, v_i)$, где $x, y in N(v_i)$. Количество таких путей равно $deg(v_i)^2$, поскольку у нас есть $deg(v_i)$ вариантов для $x$ и $deg(v_i)$ вариантов для $y$;],
  enum.item(2)[замкнутые пути вида $(v_i, v_j, x, v_j, v_i)$, где $v_j in N(v_i)$ и $x in N(v_j) backslash {v_i}$, количество таких путей равно $sum_(v_j~v_i) (deg(v_j) - 1)$;],
  enum.item(3)[замкнутые пути вдоль 4-циклов из $v_i$, существует 2 таких пути для каждого цикла, содержащего вершину $v_i$ скажем, $q_i$;]
)]

Следовательно,
$ A^4(i,i) = 2q_i + deg(v_i)^2 + sum_(v_j~v_i) (deg(v_j) - 1) \
=> tr(A^4) =\
= sum_(i=1)^n (2q_i + deg(v_i)^2 + sum_(v_j~v_i) (deg(v_j) - 1)) \
= 8q + sum_(i=1)^n (deg(v_i)^2 - deg(v_i) + sum_(v_j~v_i) deg(v_j)) \
= 8q - 2m + sum_(i=1)^n deg(v_i)^2 + sum_(i=1)^n sum_(v_j~v_i) deg(v_j) \
= 8q - 2m + sum_(i=1)^n deg(v_i)^2 + sum_(i=1)^n deg(v_i)^2 \
= 8q - 2m + 2 sum_(i=1)^n deg(v_i)^2 $]

#collolary()[Граф $G$ с $n gt.eq 2$ вершинами связен $<=>$ недиагональные элементы матрицы $B = A + A^2 + dots + A^(n-1)$ все положительные. На самом деле, $d(v_i, v_j) = min{k | A^k(i,j) gt 0}$.][
Сначала отметим, что для любого $k gt.eq 1$ все элементы $A^k$ неотрицательны и, следовательно, если $A^k (i,j) gt 0$ для некоторого $k in {1, 2, dots, n - 1}$, то $B(i,j) gt 0$.

$=>$ Предположим сначала, что $G$ связен. Тогда для любых различных вершин $v_i, v_j$ мы имеем, что $1 lt.eq d(v_i,v_j) lt.eq n-1$, поскольку существует путь из $v_i$ в $v_j$. Следовательно, если $k = d(v_i,v_j)$, то $A_k (v_i,v_j) gt 0$, а, значит, и $B(i,j) gt 0$. Следовательно, все недиагональные элементы матрицы $B$ положительны.

$arrow.l.double$ Теперь предположим, что все внедиагональные элементы матрицы $B$
положительны. Пусть $v_i$ и $v_j$ — две произвольные различные вершины. Так как $B(i,j) gt 0$, то существует минимальное $k in {1, dots, n-1}$ такое, что $A^k (i,j) gt 0$. Следовательно, существует путь длины $k$ из $v_i$ в $v_j$. Это доказывает, что $G$ связен.]

#lemma()[Для любого графа $G$ справедливо равенство $A(G) + A (G') + I = J$.][
Пусть $A = A(G)$ и пусть $A' = A(G')$. При $i eq.not j$, если $A(i,j) = 0$, то $A'(i,j) = 1$, и наоборот. Следовательно, $A(i,j) + A'(i,j) = 1$ для всех $i eq.not j$. С другой стороны, $A(i,i) = A'(i,i) = 0$ для всех $i$. Таким образом, $A(G) + A'(G ) + I = J$, как и утверждается.]

== Матрицы смежности и связность графа.

$lambda$ является собственным значением матрицы $M$, если существует вектор $x$ такой, что $M x = lambda x$.
В этом случае $x$ называется собственным вектором матрицы $M$, соответствующим собственному значению $lambda$.
Чтобы найти собственные значения $M$, найдем нули характеристического полинома $M$:
$ chi(lambda) = det(M - lambda I) = 0 $

Если $M$ — матрица размерности $n crossmark n$, то характеристический многочлен $chi(lambda)$ является многочленом порядка $n$, и $chi(lambda) = 0 <=> lambda — "собственное значение" M$. Однако, если $M$ — симметричная матрица, то важным результатом линейной алгебры является то, что все собственные значения $M$ являются вещественными числами. Кроме того, если матрица $M$ симметрична, а $x$ и $y$ являются собственными векторами $M$, соответствующими различным собственным значениям, то $x$ и $y$ ортогональны. Более того, если матрица $M$ симметрична, то существует ортонормированный базис $beta = {x_1, x_2, dots, x_n}$ пространства $RR^n$, состоящий из собственных векторов матрицы $M$.

#definition()[_Спектр графа $G$_, обозначаемый $"spec"(G)$, представляет собой список собственных значений матрицы $A$ в порядке возрастания $lambda_1 lt.eq lambda_2 lt.eq dots lt.eq lambda_n$: $"spec"(G) = (lambda_1, lambda_2, dots, lambda_n)$.]

Пусть $Delta(G)$ обозначает максимальную степень вершин графа.

#suggestion()[Для любого собственного значения $lambda$ графа $G$ верно, что $abs(lambda) lt.eq Delta(G)$.][Предположим, что $lambda$ — собственное значение $G$ с собственным вектором $x = (х_1, х_2, dots, х_n )$. Предположим, что $j$-й элемент вектора $x$ имеет максимальное абсолютное значение, то есть, $abs(x_i) lt.eq abs(x_j) forall i = 1, 2, dots, n$. Так как $А х = lambda х$ следует, что
$ lambda x_j = sum_(i=1)^n A(j,i) x_i $
и поэтому, используя неравенство треугольника, получаем
$ abs(lambda) abs(x_j) = abs(sum_(i=1)^n A(j,i) x_i) lt.eq sum_(i=1)^n abs(A(j,i)) abs(x_i) \
= abs(x_j) sum_(i=1)^n abs(A(j,i)) \
= abs(x_j) deg(v_j) lt.eq abs(x_j) Delta(G) $
Следовательно, $abs(lambda) abs(x_j) lt.eq abs(x_j) Delta(G)$, и утверждение следует из деления обеих частей неравенства на $abs(x_j) eq.not 0$.]

#suggestion()[Пусть $"spec"(G) = (lambda_1, lambda_2, dots, lambda_n)$ и пусть $d_("avg") = 2abs(E)/n$ обозначает среднее значение степеней графа $G$. Тогда $forall i=1 dots n: d_("avg") lt.eq lambda_i lt.eq Delta(G)$.]

#definition()[_Регулярный граф_ — граф, степени всех вершин которого равны]

#definition()[Регулярный граф с вершинами степени $k$ называется _$k$‑регулярным_.]

#suggestion()[Граф $G$ является $k$-регулярным, если $e = (1, 1, dots, 1)$ — собственный вектор $G$ с собственным значением $lambda = k$.][$=>$ Напомним, что $A e = (deg(v_1), deg(v_2), dots, deg(v_n))$. Если $G$ является $k$-регулярным, то $deg(v_i) = k$ для всех $v_i$, и, следовательно, $A e = (k, k, dots, k) = k e$. Таким образом, $k$ является собственным значением матрицы $A$ с соответствующим собственным вектором $e$.

$arrow.l.double$ С другой стороны, если $e$ — собственный вектор графа $G$ с собственным значением $k$, то $A e = k e = (k, k, dots, k)$ и, таким образом, $forall v_i: deg(v_i) = k$, и тогда $G$ является  $k$-регулярным.]

#definition()[Мы говорим, что два графа $G_1$ и $G_2$ являются _коспектральными_, если они имеют одинаковые (смежные) собственные значения.]

#suggestion()[Если графы $G_1$ и $G_2$ изоморфны, то $"spec"(G_1) = "spec"(G_2)$.]

= Лекция 4
== Деревья.

#definition()[_Дерево_ — это связный ациклический неориентированный (ориентированный, если корневое) граф.]

Поскольку дерево не может иметь простых циклов, дерево не может содержать кратных ребер или петель. Поэтому любое дерево должно быть простым графом.

#definition()[Несвязные ациклические графы называются _лесами_, и обладают тем свойством, что каждая из их связных компонент является деревом.]

== Свойства деревьев

#theorem()[Неориентированный граф является деревом $<=>$ между любыми двумя его вершинами существует единственный простой путь.][
$=>$ Сначала предположим, что $T$ — это дерево. Тогда $T$ — связный граф без простых циклов. Пусть $x$ и $y$ — две вершины. Поскольку $T$ связен, по теореме 3 существует простой путь между $x$ и $y$. Более того, этот путь должен быть уникальным, поскольку если бы существовал второй такой путь, то путь, образованный объединением первого пути из вершины $x$ в вершину $y$ с путем из вершины $y$ в вершину $х$, полученным путем изменения порядка вершин второго пути, образует цикл. Значит, между любыми двумя вершинами дерева существует единственный простой путь.

$arrow.l.double$ Теперь предположим, что между любыми двумя вершинами графа $T$ существует единственный простой путь. Тогда $T$ связен, поскольку между любыми двумя его вершинами существует путь. Более того, $T$ не может иметь простых циклов. Чтобы убедиться в этом, предположим, что в $T$ имеется простой цикл, содержащий вершины $x$ и $y$. Тогда между вершинами $x$ и $y$ будет 2 простых пути, поскольку простой цикл состоит из простого пути из $x$ в $y$ и второго простого пути из $y$ в $x$. Следовательно, граф с единственным простым путем между любыми двумя вершинами является деревом.]

Во многих приложениях деревьев какая-то выделенная вершина дерева обозначается как _корень_.
Указав корень, мы можем присвоить направление каждому ребру следующим образом.

#definition()[_Корневое дерево_ — это дерево, в котором одна вершина обозначена как корень, а все ребра направлены от корня.]

#definition()[Пусть $T$ — корневое дерево. Если $v$ — вершина в $T$, отличная от корня, то _отец_ вершины $v$ — это единственная
вершина $u$, такая, что существует ориентированное ребро из $u$ в $v$ (такая вершина уникальна). 

Когда $u$ является отцом вершины $v$, то $v$ называется _сыном_ вершины $u$.

Вершины, имеющие одного и того же отца, называются _братьями_.]

#definition()[_Предки вершины_, отличной от корня, — это вершины на пути от корня к этой вершине , исключая саму вершину и включая корень (то есть ее родителя, родителя ее родителя и т. д.) до тех пор, пока не будет достигнут корень).

_Потомками вершины_ $v$ являются те вершины, которые имеют $v$ в качестве предка.]

#definition()[Вершина корневого дерева называется _листом_, если у нее нет сыновей. Вершины, у которых есть сыновние, называются _внутренними вершинами_.]

#definition()[Если $a$ — вершина дерева, то _поддерево с корнем $a$_ — это подграф дерева, состоящий из $a$ и его потомков, а также всех ребер, инцидентных этим потомкам.]

#definition()[Корневое дерево называется $m$-арным деревом, если каждая внутренняя вершина имеет не более $m$ сыновей. 

Дерево называется _полным_ $m$-арным деревом, если каждая внутренняя вершина имеет ровно $m$ сыновей. $m$-арное дерево, где $m$ = 2 называется _бинарным_ деревом]

#definition()[_Упорядоченное корневое дерево_ — это корневое дерево, в котором дочерние вершины каждой внутренней вершины упорядочены (изображаются в порядке слева направо)]

#definition()[Если внутренняя вершина имеет 2 сына, первый сын называется _левым_ сыном, а второй сын называется _правым_ сыном

Поддерево, корнем которого является левый сын вершины, называется _левым поддеревом_ этой вершины, а поддерево, корнем которого является правый сын вершины, называется _правым поддеревом_ вершины.]

#theorem()[Дерево с $n$ вершинами имеет $n − 1$ ребро.][
Для доказательства этой теоремы мы воспользуемся методом математической индукции. Обратите внимание, что у любого дерева можно выбрать корень и считать дерево корневым. 

БАЗОВЫЙ ШАГ: Когда $n = 1$ , дерево с $n = 1$ вершиной не имеет ребер. Отсюда следует, что теорема верна для $n = 1$ .

ИНДУКТИВНЫЙ ШАГ: Индуктивная гипотеза утверждает, что каждое дерево с $k$ вершинами имеет $k − 1$ ребро, где $k$ — положительное целое число. Предположим теперь, что дерево $T$ имеет $k + 1$ вершину, и что $v$ является листом $T$ (который должен существовать, поскольку дерево конечно), и пусть $w$ является отцом листа $v$. Удаляем из $T$ вершину $v$ и ребро, соединяющее $w$ с $v$. В результате получится дерево $T'$ с $k$ вершинами, поскольку полученный граф по-прежнему связен и не имеет простых циклов. По индуктивному предположению $T'$ имеет $k − 1$ ребро. Отсюда следует, что $T$ имеет $k$ ребер, поскольку у него на одно ребро больше, чем у $T'$, а именно, имеется ребро, соединяющее $v$ и $w$. На этом индуктивный шаг завершен.]

#collolary()[Пусть G — это неориентированный граф с n вершинами, тогда $ cases(reverse: #true, delim: "[", "(1) G связен", "(2)  G является ациклическим") \ => "(3) G имеет n − 1 ребро" $

Кроме того, (1) $and$ (3) $=>$ (2), и (2) $and$ (3) $=>$ (1).]

#theorem()[Полное $m$-арное дерево, имеющее $i$ внутренних вершин, всего содержит $n = m i + 1$ вершин.][Каждая вершина, за исключением корня, является сыном внутренней вершины. Поскольку каждая из $i$ внутренних вершин имеет $m$ сыновей, в дереве есть $m i$ вершин, отличных от корня. Поэтому, дерево содержит $n = m i + 1$ вершин.]

#theorem()[Полное $m$-арное дерево, имеющее
#enum(numbering: "(1)",
  enum.item(1)[$n$ вершин имеет $i = (n - 1) div m$ внутренних вершин и $l = [(m - 1) n + 1] div m$ листьев,],
  enum.item(2)[у $i$ внутренних вершин есть $n = m i + 1$ вершин и $l = (m - 1) i + 1$ листьев,],
  enum.item(3)[$l$ листьев имеет $n = (m l - 1) div (m - 1)$ вершин и $i = (l - 1) div (m - 1)$ внутренних вершин.]
)][
Пусть $n$ представляет общее количество вершин, $i$ -
количество внутренних вершин, а $l$ - количество листьев. Все три части теоремы можно доказать, используя равенство, данное в теореме 9, то есть $n = m i + 1$, вместе с равенством $n = l + i$, что верно, поскольку каждая вершина является либо листом, либо внутренней вершиной.

Докажем часть (1) в качестве примера. Доказательства частей (2) и (3) выполняются аналогично. 

Решение для $i$ в $n = m i + 1$ дает $i = (n − 1) / m$. Затем вставляем это выражение для $i$ в уравнение $n = l + i$, получим
$l = n - i = n − (n − 1) / m =((m − 1) n + 1) / m$.]

#definition()[_Уровень вершины_ $v$ в корневом дереве — это длина уникального пути от корня до этой вершины. Уровень корня определяется как нулевой]

#definition()[_Высота корневого дерева_ равна длине самого длинного пути от корня до любой вершины.]

#definition()[Корневое $m$-арное дерево высоты $h$ является сбалансированным, если все его листья находятся на уровнях $h$ или $h − 1$.]

#theorem()[В $m$-арном дереве высотой $h$ имеется не более $m^h$ листьев.][Доказательство использует математическую индукцию по высоте дерева. Сначала рассмотрим $m$-арные деревья высоты 1. Эти деревья состоят из корня, имеющего не более $m$ сыновей, каждый из которых является листом. Следовательно, в $m$-арном дереве высотой 1 имеется не более $m^1 = m$ листьев. Это базовый шаг индукции.

Теперь предположим, что утверждение верно для всех $m$-арных деревьев высоты $lt h$; это индуктивная гипотеза.

Пусть $T$ — $m$-арное дерево высоты $h$. Листья дерева $T$ — это листья поддеревьев $T$, полученные путем удаления ребер от корня до каждой из вершин на уровне 1. Каждое из этих поддеревьев имеет высоту не более чем $h − 1$. Таким образом, по индуктивной гипотезе каждое из этих корневых деревьев имеет не более чем $m^(h−1)$ листьев. Поскольку существует не более $m$ таких поддеревьев, каждое из которых имеет максимум $m^(h − 1)$ листьев, то существует $l lt.eq m m^(h−1) = m^h$ листьев в корневом дереве высоты $h$.]

#collolary()[Если $m$-арное дерево высоты $h$ имеет l листьев, то $h gt.eq ceil(log_m l)$. Если $m$-арное дерево полное и сбалансированное, то $h = ceil(log_m l)$.][
Мы знаем, что $l lt.eq m^h$ теоремы 11. Возьмем логарифм по основанию $m$ от обеих частей: $log_m l lt.eq h$. Поскольку $h$ — целое число, то $h gt.eq ceil(log_m l)$.

Теперь предположим, что дерево сбалансировано. Тогда каждый лист находится на уровне $h$ или $h - 1$, и поскольку высота дерева равна $h$, на уровне $h$ имеется по крайней мере 1 лист. Из этого следует, что листьев должно быть $gt m^(h-1)$.
Поскольку $l lt.eq m^h$, то $m^(h-1 ) lt l lt.eq m^h$. Взяв логарифмы по основанию $m$ в этом неравенстве, получаем $h - 1 lt log_m l lt.eq h$. Следовательно, $h = ceil(log_m l)$.]

== Приложения деревьев.

#definition()[Корневое дерево, в котором каждая внутренняя вершина соответствует принятию решения, а поддерево с корнем в этой вершине соответствует каждому возможному результату принятия решения, называется _деревом решений_. Возможные решения проблемы соответствуют путям к листьям этого корневого дерева.]

Используя деревья решений в качестве моделей, можно найти нижнюю границу для наихудшего случая сложности алгоритмов сортировки, основанных на попарных сравнениях. Мы можем использовать деревья решений для моделирования алгоритмов сортировки и определения оценки наихудшей сложности этих алгоритмов. Обратите внимание, что при наличии $n$ элементов существует $n!$ возможных упорядочений этих элементов, поскольку каждая из $n!$ перестановок этих элементов может быть правильным порядком.

Алгоритм сортировки, основанный на попарных сравнениях, можно представить в виде бинарного дерева решений, в котором каждая внутренняя вершина представляет собой сравнение двух элементов. Каждый лист представляет собой одну из $n!$ перестановок $n$ элементов.

Наибольшее количество использованных сравнений соответствует наибольшей длине пути в дереве решений, представляющем процедуру сортировки.

Поскольку высота бинарного дерева с $n!$ листьями $gt.eq ceil(log n!)$ (используя следствие 5), необходимы $gt.eq ceil(log n!)$ сравнений.

#theorem()[Алгоритм сортировки, основанный на попарных сравнениях, требует $gt.eq ceil(log n!)$ сравнений.]

Мы можем использовать теорему 12, чтобы получить $Omega$-оценку для числа сравнений с помощью алгоритма сортировки, основанного на попарном сравнении. Нам нужно только отметить, что $ceil(log n!)$ это $Omega(n log n)$.

#collolary()[Число сравнений, используемых алгоритмом сортировки для сортировки $n$ элементов на основе попарных сравнений, равно  $Omega(n log n)$.]

Один из способов убедиться, что ни одна строка битов не соответствует более чем одной последовательности букв — это кодировать буквы таким образом, чтобы битовая строка для буквы никогда не встречалась как начало битовой строки для другой буквы. Коды с таким свойством называются префиксными кодами.

Префиксный код можно представить с помощью двоичного дерева, где символы являются метками листьев в дереве.

Алгоритм, который принимает в качестве входных данных частоты (вероятности появления) символов в строке и выдает в качестве выходных данных префиксный код, который кодирует строку, используя наименьшее возможное количество битов среди всех возможных двоичных префиксных кодов для этих символов. Этот алгоритм, известный как _кодирование Хаффмана_.

==== Алгоритм кодирования Хаффмана
#text[
процедура `Huffman`(\
`С`: буквы $а_i$ с частотами $w_i$, $i = 1 dots n$)\
$F :=$ лес из $n$ корневых деревьев, каждое из которых состоит из одной вершины $а_i$, и присвоеннного веса $w_i$;\
пока $F$ не дерево:\
Заменить корневые деревья $Т$ и $Т'$ наименьших весов из $F$ на дерево, имеющее новый корень и имеющее $Т$ в качестве своего левого поддерева и $Т'$ в качестве правого поддерева так что $w(T) gt.eq W(T')$;\
Пометить новое ребро к $Т$ нулем, а новое ребро к $T'$ - единицей;\
Присвоить $w(T) + w(T')$ в качестве веса нового дерева.\

{код Хаффмана для символа $а_i$, представляет собой конкатенацию меток ребер в уникальном пути от корня до вершины $а_i$

Алгоритм начинается с леса деревьев, каждое из которых состоит из 1 вершины, где каждая вершина имеет букву в качестве своей метки, а вес этой вершины равен частоте буквы, являющейся ее меткой.
На каждом шаге мы объединяем 2 дерева с наименьшим весом в одно дерево, вводя новый корень и помещая дерево с большим весом в качестве его левого поддерева, а дерево с меньшим весом — в качестве его правого поддерева .
Кроме того, мы присваиваем сумму весов двух поддеревьев этого дерева в качестве общего веса дерева. Алгоритм завершается, когда построено дерево, то есть когда лес сводится к одному дереву.]

= Лекция 5
== Остовные деревья.

#definition()[Пусть $G$ — простой граф. Остовное дерево графа $G$ — это подграф $G$, представляющий собой дерево, содержащее все вершины $G$.]

#theorem()[Простой граф связен $<=>$ он имеет остовное дерево.][
$arrow.l.double$ Сначала предположим, что простой граф $G$ имеет остовное дерево $Т$. $T$ содержит каждую вершину $G$. В $T$ существует путь между любыми двумя его вершинами. Поскольку $T$ является подграфом $G$, в $G$ существует путь между любыми двумя его вершинами. Следовательно, $G$ связен.

$=>$ Теперь предположим, что $G$ связен. Если $G$ не является деревом, он должен содержать простой цикл. Удалим ребро в одном из этих простых циклов. 

Полученный подграф имеет на одно ребро меньше, но по-прежнему содержит все вершины $G$ и является связным. 

Этот подграф по-прежнему связен, поскольку при удалении ребра из цикла, остается второй путь между вершинами, не содержащий это ребро. Если этот подграф не является деревом, то он имеет простой цикл; поэтому, как и прежде, удаляем ребро, которое находится в простом цикле. Повторяем этот процесс до тех пор, пока не останется ни одного простого цикла. Это возможно, поскольку в графе имеется лишь конечное число ребер. Процесс завершается, когда не остается простых циклов. Дерево получается потому, что граф остается связным при удалении ребер. Это дерево является остовным, поскольку из графа удалялись только ребра.]

== Поиск в ширину (BFS).

Мы можем создать остовное дерево простого графа, используя поиск в ширину. Будет построено корневое дерево, а основание этого корневого дерева образует остовное дерево. Произвольно выбираем корень среди вершин графа. Затем добавим все ребра, инцидентные этой вершине. Новые вершины, добавленные на этом этапе, становятся вершинами уровня 1 в остовном дереве.Произвольно упорядочим их.

Далее для каждой вершины на уровне 1, посещённой по порядку, добавляем каждое ребро, инцидентное этой вершине, в дерево, если оно не создаёт простой цикл.

Произвольно упорядочим дочерние элементы каждой вершины уровня 1. Это создает вершины на уровне 2 дерева.

Повторяем ту же процедуру, пока не будут добавлены все вершины дерева.

Процедура заканчивается, поскольку в графе имеется только конечное число ребер .

Остовное дерево получается, поскольку мы создали дерево, содержащее каждую вершину графа.

==== Алгоритм BFS
```pascal
procedure BFS1(G: connected graph with vertices V1, ..., Vn)
T := tree consisting only of vertex v1;
L := empty list;
put v1, in the list L of unprocessed vertices;
while (L is not empty)
  remove the first vertex, v, from L;
  for each neighbor w of v
    if w is not in L and not in T 
    then 
      add w to the end of the list L;
      add w and edge (v, w) to T.
```

== Расширенный поиск в ширину (BFS2).

Процедура поиска в ширину `BFS2`, представленная ниже, предполагает, что входной граф $G = (V, E)$ представлен с использованием списков смежности. 

Он связывает несколько дополнительных атрибутов с каждой вершиной графа $G$.

Будем хранить цвет каждой вершины $u in V$ в атрибуте $u."color"$ и предшественника $u$ в атрибуте $u.pi$.

Если $u$ не имеет предшественника (например, если $u = s$ или $u$ не была обнаружена), то $u.pi = "NIL"$. Атрибут $u.d$ будет содержать расстояние от источника $s$ до вершины $u$, вычисленное алгоритмом. Алгоритм также использует FIFO-очередь $Q$ для управления множеством серых вершин.

==== Алгоритм BFS2
\
$"BFS2"(G, s)\
"01 for each vertex " u in G.V backslash {s}:\
"02   " u."color" = "WHITE"\
"03   " u.d = infinity\
"04   " u.pi = "NIL"\
"05 " s."color" = "GRAY"\
"06 " s.d = 0\
"07 " s.pi = "NIL"\
"08 " Q = emptyset\
"09 " "ENQUEUE"(Q,s)\
"10 " "while" Q eq.not emptyset:\
"11   " u = "DEQUEUE"(Q)\
"12   " "for each " v in G."Adj"[u]:\
"13     " "if " v."color" == "WHITE":\
"14       " v."color" = "GRAY"\
"15.      " v.d = u.d + 1\
"16       " v.pi = u\
"17.      " "ENQUEUE"(Q V)\
"18   " u."color" = "BLACK"\
$

Общее время выполнения процедуры `BFS` (`BFS2`) составляет $O(V+E)$.

Таким образом, поиск в ширину выполняется за время, линейно зависящее от размера представления списка смежности графа.

== Кратчайшие пути в графе.

`BFS2` находит расстояние до каждой достижимой вершины в графе $G = (V, E)$ от заданной исходной вершины $s in V$. Определим кратчайшее расстояние $delta(s,v)$ от $s$ до $v$ как минимальное количество ребер в любом пути от $s$ до $v$; если пути из $s$ в $v$ нет, то  $delta(s,v) = infinity$. Назовем путь длины $delta(s,v)$ из $s$ в $v$ кратчайшим путем из $s$ в $v$.

#lemma()[Пусть $G = (V, E)$ — ориентированный или неориентированный граф, и пусть $s in V$ — произвольная вершина. Тогда для любого ребра $(u,v) in E$, $delta(s,v) lt.eq delta(s,u) + 1$.][
Если $u$ достижима из $s$, то $v$ тоже достижима. В этом случае кратчайший путь из $s$ в $v$ не может быть длиннее кратчайшего пути из $s$ в $u$, за которым следует ребро $(u, v)$, и, значит, неравенство выполняется. Если $u$ недостижима из $s$, то $delta(s,u) = infinity$, и неравенство выполняется.]

#lemma()[Пусть $G = (V, E)$ — ориентированный или неориентированный граф, и предположим, что `BFS` выполняется на $G$ из заданной исходной вершины $s in V$. Тогда по завершении `BFS` для каждой вершины $v in V$, значение $v.d$, вычисленное `BFS`, удовлетворяет неравенству $v.d gt.eq delta(s, v)$.][
Мы используем индукцию по количеству операций `ENQUEUE`.

Индуктивная гипотеза заключается в том, что $forall v in V: v.d gt.eq delta(s,v)$.

Основой индукции является ситуация сразу после постановки $s$ в очередь в строке 9 `BFS2`. Индуктивная гипотеза здесь верна, потому что $s.d = 0 = delta(s, s)$ и $forall v in V backslash {s}: v.d = infinity gt.eq delta(s, v)$.

В качестве шага индукции рассмотрим белую вершину $v$, обнаруженную во время поиска из вершины $u$. Индуктивная гипотеза подразумевает, что $u.d gt.eq delta(s, u)$. Из присваивания, выполненного в строке 15 `BFS2` и из леммы 2, получаем​ $ v.d = u.d + 1 gt.eq delta(s,u) + 1 gt.eq delta(s,v) $

Вершина $v$ попадает в очередь, и она больше никогда не попадет в очередь снова, поскольку она также становится серой, а предложение `then` в строках 14–17 выполняется только для белых вершин. Таким образом, значение $v.d$ больше никогда не изменится, и индуктивная гипотеза сохраняется.]

#theorem()[Пусть $G = (V, E)$ — ориентированный или неориентированный граф, и предположим, что `BFS2` запускается на $G$ из заданной исходной вершины $s in V$. Тогда во время выполнения, `BFS2` обнаруживает каждую вершину $v in V$, достижимую из источника $s$, и по завершении BFS2 $forall v in V: v.d = delta(s,v)$.]

== Деревья поиска в ширину.

#definition()[
Процедура `BFS2` строит дерево поиска в ширину при поиске по графу. Ребра дерева соответствует атрибутам $pi$. 

Более формально, для графа $G = (V, E)$ с источником $s$ мы определяем подграф предшествования как $G_pi= (V_pi, E_pi)$, где $ V_pi = {v in V : v.pi eq.not "NIL"} union {s}$ и $E_pi = {(v.pi,v) : v in V backslash {s}}$.

Подграф предшествования $G_pi$ является деревом поиска в ширину, если $V_pi$ состоит из вершин, достижимых из $s$, и для всех $v in V_pi$, подграф $G_pi$ содержит единственный простой путь из $s$ в $v$, который также является кратчайшим путем из $s$ в $v$ в $G$.]

Дерево поиска в ширину на самом деле является деревом, поскольку оно
связно и $abs(E) = abs(V) - 1$.

Мы называем ребра в $E$ древесными ребрами. Следующая лемма показывает, что подграф предшествования, созданный `BFS2` представляет собой дерево поиска в ширину.

#lemma()[При применении к ориентированному или неориентированному графу $G = (V, E)$ `BFS2` строит атрибут $pi$ так, что подграф предшествования $G_pi = (V_pi, E_pi)$ является  деревом поиска в ширину.][
Строка 16 алгоритма BFS2 устанавливает что $v.pi = u <=> (u,v) in Е$, и $delta(s,v) lt infinity$ — то есть, если $v$ достижима из $s$
— таким образом, $V_pi$ состоит из вершин в $V$, достижимых из $s$.

Поскольку $G_pi$ образует дерево, оно содержит уникальный
простой путь из $s$ в каждую вершину в $V_pi$.

Применяя теорему 14 индуктивно, заключаем, что каждый такой путь является кратчайшим путем в графе $G$.]

== Поиск в глубину.

Мы можем построить остовное дерево для связного простого графа,
используя поиск в глубину (Depth First Search, DFS). DFS сформирует корневое дерево, а остовное дерево будет основанием
этого корневого дерева. 

Произвольно выберем вершину графа в качестве корня. Сформируем путь, начинающийся из выбранной вершины путем последовательного добавления вершин и ребер, где каждое новое ребро инцидентно предыдущей вершине пути и вершине, которой еще нет в пути. Продолжим добавлять вершины и ребра к этому пути как можно дольше. 

Если путь проходит через все вершины графа, то дерево, состоящее из
этого пути представляет собой остовное дерево.

Однако, если путь не проходит через все вершины, надо добавить больше вершин и ребер. Надо вернуться к предпоследней вершине пути и, если возможно, сформировать новый путь, начинающийся в этой вершине и проходящий через вершины, которые еще не были посещены. Если это невозможно, переместиться назад еще одну вершину пути, то есть на 2 вершины пути, и попробовать еще раз.

Повторим эту процедуру, начиная с последней посещенной вершины, двигаясь назад по пути на один шаг по одной вершине за раз, формируя новые пути, которые являются настолько длинными, насколько это возможно, пока больше ребер не может быть добавлено.

Поскольку граф имеет конечное число ребер и является связным, этот процесс заканчивается созданием остовного дерева.

Каждая вершина, которая является конечной на некотором этапе алгоритма, будет быть листом в корневом дереве, и каждая вершина, где начинает строиться новый путь, будет внутренней вершиной.

Поиск в глубину также называется бэктрэкингом (откатом), поскольку алгоритм возвращается к ранее посещенным вершинам для добавления путей.

Мы говорим, что мы осуществляем _поиск из вершины $v$_, когда мы выполняем шаги поиска в глубину, начинающегося с момента когда $v$ добавляется в дерево и завершающегося, когда мы вернулись к $v$ в последний раз.

В алгоритме DFS мы строим остовное дерево графа $G$ с вершинами $v_1, dots, v_n$ сначала выбрав вершину $v_1$ в качестве корня.

Первоначально мы задали $T$ как дерево, содержащее только $v_1$. На каждом шаге мы добавляем новую вершину к дереву $T$ вместе с ребром от вершины, уже имеющейся в $T$, к этой новой вершине и ведем поиск из этой новой вершины. Обратите внимание, что по завершении алгоритма $T$ не содержит простых циклов, поскольку не добавляется ни одного ребра, соединяющего 2 вершины, уже находящиеся в дереве. Более того, $Т$ остается связным по мере его создания. Поскольку $G$ связен, каждая вершина в $G$ посещается алгоритмом и добавляется в дерево. Из этого следует, что $Т$ является остовным деревом графа $G$.

==== Алгоритм DFS
```pascal
procedure DFS1(G: connected graph with vertices v1,...,vn)
T := tree consisting only of the vertex v1;
visit(v1).

procedure visit(v: vertex of G)
for each vertex w adjacent to v and not yet in T
  add vertex w and edge (v, w) to T;
  visit(w).
```

== Расширенный поиск в глубину (DFS2).

Как и в `BFS2`, всякий раз, когда `DFS2` обнаруживает вершину $v$ во время просмотра списка смежности уже обнаруженной вершины $u$, он регистрирует это событие, устанавливая атрибут
предшественника вершины $v$, $v.pi = u$.

В отличие от `BFS2`, подграф предшествования которого образует дерево, подграф предшествования, созданный `DFS2`, может состоять из нескольких деревьев , поскольку поиск может повторяться из нескольких источников. Поэтому мы определяем подграф предшествования `DFS2` немного иначе, чем в `BFS`: $ G_pi = (V, E_pi) $ $ E_pi = {(v.pi, v) : v in V и v.pi eq.not "NIL"}. $

Подграф предшествования `DFS2` образует лес поиска в глубину, состоящий из нескольких деревьев поиска в глубину. Ребра в $E_pi$ являются древесными ребрами.

Как и в `BFS2`, `DFS2` раскрашивает вершины во время поиска, чтобы обозначить их состояние. Каждая вершина первоначально белая, в момент обнаружения в процессе поиска вершина становится серой, а затем она становится черной, когда поиск из этой вершины завершен, то есть когда ее список смежности полностью просмотрен.

Этот метод гарантирует, что каждая вершина попадает ровно в 1 дерево
поиска в глубину, так что эти деревья не пересекаются.

Каждая вершина $v$ имеет 2 метки времени:
1. $v.d$ записывает, когда $v$ обнаружена в первый раз (и становится серой),
2. $v.f$ записывает, когда поиск в глубину завершает проверку списка смежности вершины $v$ (и делает вершину $v$ черной).

Эти временные метки предоставляют важную информацию о структуре графа.

Временные метки представляют собой целые числа от 1 до $2abs(V)$, поскольку для каждой из вершин $abs(V)$ существует 1 событие обнаружения и 1 событие завершения обработки. Для каждой вершины $u: u.d lt u.f$ (1).

Вершина u является:
- БЕЛОЙ перед моментом времени $u.d$,
- СЕРОЙ между временем $u.d$ и временем $u.f$, и
- ЧЁРНОЙ после этого.

Следующий псевдокод представляет собой базовый алгоритм DFS2. Входной граф $G$ может быть неориентированным или ориентированным. Переменная `time` — это глобальная переменная, которую мы используем для отметки времени.

==== Алгоритм DFS2
\
$"DFS2"(G)\
"01 " "for each vertex" u in G.V\
"02   " u."color" = "WHITE"\
"03   " u.pi = "NIL"\
"04 " "time" = 0\
"05 " "for each vertex" u in G.V\
"06   " "if" u."color" == "WHITE"\
"07     " "DFS-VISIT"(G, u)\
\
"DFS-VISIT"(G, u)\
"   /* белая вершина u"\
"      только что обнаружена */"\
"01 " "time" = "time" + 1\
"02 " u.d = "time"\
"03 " u."color" = "GRAY"\
"   // просмотр ребра (u, v)"\
"04 " "for each" v in G."Adj"[u]\
"05   " "if" v."color" == "WHITE"\
"06     " v.pi = u\
"07   " "DFS-VISIT"(G, v)\
"   /* вершина u становится черной;"\ 
"      ее обработка завершена */"\
"08 " u."color" = "BLACK"\
"09 " "time" = "time" + 1\
"10 " u.f = "time"\
$

== Свойства DFS.

`DFS2` дает ценную информацию о структуре графа. Возможно, самым основным свойством `DFS` является то, что подграф предшествования $G_pi$ действительно образует лес деревьев, поскольку структура деревьев поиска в глубину в точности отражает структуру рекурсивных вызовов `DFS-VISIT`.
1. То есть, $u = v.pi$ (вершина $u$ является отцом вершины v): $<=>$ $"DFS-VISIT"(G, v)$ был вызван во время поиска в списке смежности $u$.
2. Кроме того, вершина $v$ является потомком вершины $u$ в глубинном остовном лесу $<=>$ $v$ обнаружена в то время, когда $u$ является серой.
3. Еще одним важным свойством `DFS2` является то, что время обнаружения и завершения имеет скобочную структуру.

Если мы представим открытие вершины $u$ с помощью левой скобки
"$(u$", а ее завершение — с помощью правой скобки "$u)$", то история открытий и завершений образует правильно построенное выражение в том смысле, что скобки правильно вложены.

#theorem()[В любом `DFS2` графе (ориентированном или
неориентированном) $G = (V, E)$ для любых 2 вершин $u$ и $v$ выполняется ровно 1 из следующих 3 условий:
#enum(numbering: "(1)",
  enum.item(1)[интервалы $[u.d, u.f]$ и $[v.d, v.f]$ полностью не пересекаются, и ни $u$, ни $v$ не являются потомками друг друга в глубинном остовном лесу,],
  enum.item(2)[интервал $[u.d, u.f]$ полностью содержится в интервале $[v.d, v.f]$, а $u$ является потомком $v$ в дереве поиска в глубину,],
  enum.item(3)[интервал $[v.d, v.f]$ полностью содержится в интервале $[u.d, u.f]$, а $v$ является потомком $u$ в дереве поиска в глубину.])  
][
Начнем со случая, когда $u.d lt v.d$.

Мы рассматриваем 2 подслучая, в зависимости от того, $v.d lt u.f$ или нет.
#enum(numbering: "(1)",
  enum.item(1)[$v.d < u.f$, вершина $v$ была обнаружена, когда $u$ была еще серой, что подразумевает, что $v$ является потомком $u$. Более того, поскольку $v$ была обнаружена позже, чем $u$, все исходящие ребра $v$ исследуются, и $v$ завершается, прежде чем поиск возвращается в $u$ и завершает обработку $u$. В этом случае, следовательно, интервал $[v.d, v.f]$ целиком содержится внутри интервала $[u.d, u.f]$.],
  enum.item(2)[В случае, когда $u.f lt v.d$, и по неравенству $u.d lt u.f$ (1), $u.d lt u.f lt v.d lt v.f$; таким образом, интервалы $[u.d, u.f]$ и $[v.d, v.f]$ не пересекаются. Поскольку интервалы не пересекаются, ни одна вершина не была обнаружена, то время как другая была серой, и поэтому ни одна из вершин не является потомком другой.]
)

Случай, когда $u.d gt v.d$, аналогичен, но роли $u$ и $v$ в приведенном выше рассуждении меняются местами.]

#collolary()[Вершина $v$ является собственным потомком вершины $u$ в глубинном остовном лесу для (ориентированного или неориентированного) графа $G$ $<=>$ $u.d lt v.d lt v.f lt u.f$.]

== Классификация рёбер.

Мы можем определить 4 типа ребер в терминах леса глубины $G_pi$ произведенный `DFS2` на ориентированном графе $G$:
1. Древесные ребра — это ребра в глубинном остовном лесу $G_pi$. Ребро $(u, v)$ является древесным ребром, если $v$ была впервые обнаружена при исследовании ребра $(u, v)$.
2. Обратные ребра — это те ребра $(u, v)$, которые соединяют вершину $u$ с предком в дереве поиска в глубину. Мы считаем петли, которые могут встречаться в ориентированных графах, обратными ребрами.
3. Прямые ребра — это те недревесные ребра $(u, v)$, которые соединяют вершину $u$ с потомком в дереве поиска в глубину.
4. Поперечные ребра — все остальные ребра. Они могут проходить между вершинами в одном и том же дереве поиска в глубину, пока одна вершина не является предком другой, или они могут проходить между вершинами в разных деревьях поиска в глубину.

#theorem()[При поиске в глубину на неориентированном графе $G$ каждое ребро $G$ является либо древесным ребром, либо обратным ребром.][Пусть ${u, v}$ — произвольное ребро графа $G$, и предположим без ограничения общности, что $u.d lt v.d$. Тогда поиск должен обнаружить и завершить $v$ до того, как он завершит обработку $u$ (пока $u$ серая), поскольку $v$ находится в списке смежности $u$.
1. Если в первый раз поиск исследует ребро ${u, v}$ в направлении от $u$ к $v$, то $v$ остается необнаруженной (белой) до этого момента, иначе поиск уже прошел бы по этому ребру в направлении от $v$ к $u$. Таким образом, $(u, v)$ становится древесным ребром.
2. Если поиск сначала исследует ${u, v}$ в направлении от $v$ к $u$, то ${u, v}$ является обратным ребром, поскольку $u$ все еще серая в момент первого прохода по ребру.]
